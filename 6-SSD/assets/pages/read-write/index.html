<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf8" />
    <title>Медиа-курс "Накопители на твёрдотельной памяти (SSD)"</title>
    <link rel="shortcut icon" type="image/x-icon" href="../../images/favicon.png" />
    <link rel="stylesheet" type="text/css" href="../../css/ui-darkness/jquery-ui-1.9.2.custom.min.css" />
    <link rel="stylesheet" type="text/css" href="../../css/lightbox.css"  />
    <link rel="stylesheet" type="text/css" href="../../css/menu.css">
    <link rel="stylesheet" type="text/css" href="../../css/style.css" />
  	<script type="text/javascript" src="../../js/jquery-1.8.2.min.js"></script>
  	<script type="text/javascript" src="../../js/jquery-ui-1.9.2.custom.min.js"></script>
    <script type="text/javascript" src="../../js/lightbox.js"></script>
    <script type="text/javascript" src="../../js/scripts.js"></script>
  	<!--[if lt IE 9]>
  	<script src="../../js/html5.min.js"></script>
  	<![endif]-->
  </head>
	<body id="section5-1">
    <div id="wrapper">
        <a id="back" href="../../../start.html" title="Назад на главную"></a>
<br><br><br>
       <h1>4. Как работает SSD - накопитель</h1>
        <div class="section">
         
          <p>Для чтения блока данных в винчестере сначала нужно вычислить, где он находится, потом переместить блок магнитных головок на нужную дорожку, подождать пока нужный сектор окажется под головкой и произвести считывание. Причем хаотические запросы к разным областям жесткого диска еще больше сказываются на времени доступа. При таких запросах HDD вынуждены постоянно «гонять» головки по всей поверхности «блинов» и даже переупорядочивание очереди команд спасает не всегда. А в SSD все просто – вычисляем адрес нужного блока и сразу же получаем к нему доступ на чтение / запись. Никаких механических операций – всё время уходит на трансляцию адреса и передачу блока. Чем быстрее flash  - память, контроллер и внешний интерфейс, тем быстрее доступ к данным.</p>
                  <p>А вот при изменении / стирании данных в SSD - накопителе не так все просто. Микросхемы NAND flash -памяти оптимизированы для секторного выполнения операций. flash  - память пишется блоками по 4 Кб, а стирается по 512 Кб. При модификации нескольких байт внутри некоторого блока контроллер выполняет следующую последовательность действий:</p>				  
				  <ol>
            <li>считывает блок, содержащий модифицируемый блок во внутренний буфер/кеш;</li>
            <li>модифицирует необходимые байты;</li>
            <li>выполняет стирание блока в микросхеме flash  - памяти;</li>
            <li>вычисляет новое местоположение блока в соответствии с требованиями алгоритма перемешивания;</li>
			 <li>записывает блок на новое место.</li>
          </ol>				  
         		  <p>Вот тут и сказывается оптимизация ОС для работы с HDD. При удалении файлов операционная система не производит физическую очистку секторов на диске, а только помечает файлы как удаленные, и знает, что занятое ими место можно заново использовать. Работе самого накопителя это никак не мешает и разработчиков интерфейсов этот вопрос раньше не волновал. Если такой метод удаления помогает повысить производительность при работе с HDD, то при использовании SSD становится проблемой. В SSD, как и в традиционных жестких дисках, данные все еще хранятся на диске после того, как они были удалены операционной системой. Но дело в том, что твердотельный накопитель не знает, какие из хранящихся данных являются полезными, а какие уже не нужны и вынужден все занятые блоки обрабатывать по длинному алгоритму.</p>
		    <p>Прочитать, модифицировать и снова записать на место, после очистки затронутых операцией ячеек памяти, которые с точки зрения ОС уже удалены. Следовательно, чем больше блоков на SSD содержит полезные данные, тем чаще приходится прибегать к процедуре чтение>модификация>очистка>запись, вместо прямой записи. Вот здесь пользователи SSD сталкиваются с тем, что быстродействие диска заметно снижается по мере их заполнения файлами. Накопителю просто не хватает заранее стёртых блоков. Максимум производительности демонстрируют чистые накопители, а вот в ходе их эксплуатации реальная скорость понемногу начинает снижаться.</p>
			  <p>Раньше в интерфейсе ATA просто не было команд для физической очистки блоков данных после удаления файлов на уровне ОС. Для HDD они просто не требовались, но появление SSD заставило пересмотреть отношение к данному вопросу. В результате в спецификации ATA появилась новая команда DATA SET MANAGEMENT, более известная как Trim. Она позволяет OC на уровне драйвера собирать сведения об удаленных файлах и передавать их контроллеру накопителя. </p>  
			  <p>В периоды простоя, SSD самостоятельно осуществляет очистку и дефрагментацию блоков отмеченных как удаленные в ОС. Контроллер перемещает данные так, чтобы получить больше предварительно стертых ячеек памяти, освобождая место для последующей записи. Это дает возможность сократить задержки, возникающие в ходе работы.</p>
			    <p>Но для реализации Trim необходима поддержка этой команды прошивкой накопителя и установленным в ОС драйвером. На данный момент только самые последние модели SSD «понимают» TRIM, а для старых накопителей нужно прошить контроллер для включения поддержки этой команды. Среди операционных систем команду Trim поддерживают: Windows 7/8, Windows Server 2008 R2/2012, Linux 2.6.33, FreeBSD 8.3, 9.2, 10.0,  OpenSolaris, Mac OS X, Android . Для остальных ОС необходимо инсталлировать дополнительные драйвера и утилиты. </p>
				  <p>Например, для SSD от Intel существует специальная утилита SSD Toolbox, которая может выполнять процедуру синхронизации с ОС по расписанию. Кроме оптимизации, утилита позволяет выполнять диагностику SSD и просматривать SMART-данные всех накопителей компьютера. С помощью SMART, можно оценить текущую степень износа SSD – параметр E9 отражает оставшееся количество циклов очистки NAND-ячеек в процентах от нормативного значения. Когда величина, уменьшаясь от 100, дойдет до 1, можно ожидать скорое появление «битых» блоков.</p>
				   
        </div><!-- .section -->

       <div id="footer">
           <div class="text_bru"><strong>Руководитель:</strong> Прудников В.М.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>Разработчик:</strong> Гончарова Т.Г.<br />Белорусско-Российский университет,  кафедра "Автоматизированные системы управления" &copy; 2014</div>
        </div>
    </div><!-- #wrapper -->
    
 
  		
    <a href="#top" class="top-link" id="top-link">&#9650; Наверх</a>
    <script type="text/javascript" src="../../js/menu.min.js"></script>
  </body>
</html>